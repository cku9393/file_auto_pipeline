# ADR-0003: AI 파싱 레이어 설계

| 항목 | 내용 |
|------|------|
| **상태** | Accepted |
| **작성일** | 2024-01-15 |
| **결정자** | 프로젝트 팀 |
| **관련 문서** | [spec-v2.md](../spec-v2.md) Section 8 |

## Context (배경)

사용자가 채팅 형식으로 자유롭게 입력하면, AI가 이를 구조화된 데이터로 변환해야 합니다.

### 요구사항

1. **자연어 입력**: "WO-001, L1 라인이야" 같은 자유 형식 지원
2. **파일 첨부**: Excel, 사진, 스캔 PDF 등 다양한 형식
3. **OCR**: 이미지/PDF에서 텍스트 추출
4. **구조화**: 자연어 → definition.yaml 기반 JSON

### 고려한 대안들

#### 대안 1: 규칙 기반만

정규식 + 패턴 매칭으로 파싱

**장점**: 오프라인 작동, 비용 없음  
**단점**: 유연성 부족, 다양한 입력 형식 대응 어려움

#### 대안 2: LLM 전담

모든 파싱을 LLM이 처리

**장점**: 유연함  
**단점**: 비용, 환각 위험, 검증 로직 분산

#### 대안 3: LLM 구조화 + core 검증 (선택됨)

- LLM: 입력 정리/구조화 **제안**
- core/validate: 최종 **판정**

**장점**: 유연성 + 안전성 분리  
**단점**: 구현 복잡도 증가

## Decision (결정)

**LLM은 구조화 제안만, 최종 판정은 core validate가 담당한다.**

### 핵심 규칙

| 규칙 | 설명 |
|------|------|
| **LLM 역할 한정** | 입력 정리/구조화 제안만 (판정 권한 없음) |
| **core 판정** | definition.yaml 기반 검증은 core/validate가 담당 |
| **OCR 분리** | OCR은 별도 단계로 분리 (디버깅 용이) |
| **원본 보관** | intake_session.json에 원문 저장 (불변) |
| **Provider 추상화** | 모델 교체 가능하게 설계 |

### 파싱 흐름

```
사용자 입력 (채팅)
      │
      ▼
intake_session.json 저장 (원문 보관 - 불변)
      │
      ▼
1단계: OCR (Gemini) ──── 실패 시 → 사람 확인 UX
      │
      ▼
2단계: 구조화 (Claude) ── 제안만, 판정 아님
      │
      ▼
3단계: 검증 (core/validate) ── 최종 판정
      │
      ▼
기존 파이프라인 (SSOT → Photos → Hash → Render)
```

### intake_session.json 불변성 (규범, v1.0)

> **스키마 버전**: `1.0`

```json
{
  "schema_version": "1.0",
  "session_id": "uuid-v4",
  "immutable": true,
  
  "messages": [...],           // 원문 - 절대 수정 금지
  
  "ocr_results": {
    "overview.jpg": {
      "success": true,
      "text": "추출된 텍스트...",
      "confidence": 0.92,
      "model_requested": "gemini-3-pro-preview",
      "model_used": "gemini-2.5-flash",      // 실제 사용 모델 (fallback 시 다를 수 있음)
      "fallback_triggered": true,
      "processed_at": "2024-01-15T09:30:05Z"
    }
  },
  
  "extraction_result": {
    "fields": {...},
    "measurements": [...],
    "missing_fields": [...],
    "model_requested": "claude-opus-4-5-20251101",
    "model_used": "claude-opus-4-5-20251101",  // 실제 사용 모델 (감사/재현용)
    "extracted_at": "2024-01-15T09:30:10Z"
  },
  
  "user_corrections": [...]    // 사용자 수정값 별도 기록
}
```

**모델 기록 필수 키** (감사/재현성):

| 키 | 필수 | 설명 |
|----|:----:|------|
| `model_requested` | ✅ | config에 설정된 모델 |
| `model_used` | ✅ | 실제 호출된 모델 (fallback 시 다름) |
| `fallback_triggered` | OCR만 | fallback 발생 여부 |

| 규칙 | 설명 |
|------|------|
| **messages 불변** | 원문은 절대 수정 금지 |
| **append only** | 후처리 결과는 별도 섹션에 추가만 |
| **수정값 분리** | UI 수정은 user_corrections에 기록 |
| **덮어쓰기 금지** | 원문 덮어쓰기 시도 시 에러 |

**실패 정책**:
- messages 덮어쓰기 시도 → **에러**
- schema_version 누락 → **에러**
- model_used 누락 → **에러** (재현성 보장 필수)

### Provider 추상화

> **모델 기본값 (규범)**:  
> - LLM: `claude-opus-4-5-20251101` (Claude Opus 4.5)  
> - OCR: `gemini-3-pro-preview` (Gemini 3.0 Pro)  
>   - **Fallback**: `gemini-2.5-flash` (로드 실패 시)
> 
> 모델명은 문서 본문에 하드코딩하지 않고, **config만 SSOT**로 한다.  
> 모델 변경 시 config만 수정하면 됨.

```yaml
# configs/default.yaml
ai:
  llm:
    provider: anthropic
    model: claude-opus-4-5-20251101  # 기본값 (config SSOT)
  ocr:
    provider: gemini
    model: gemini-3-pro-preview      # 기본값 (config SSOT)
    fallback: gemini-2.5-flash       # 로드 실패 시 fallback (null이면 재시도 없이 실패)
```

### OCR Fallback 예외 정책 (규범)

| 예외 유형 | Fallback 타는가? | 동작 |
|-----------|:----------------:|------|
| `NotFound` (모델명 오류/미지원) | ✅ | fallback 모델로 재시도 |
| `ServiceUnavailable` (5xx) | ✅ | fallback 모델로 재시도 |
| `ResourceExhausted` (429 쿼터/레이트리밋) | ✅ | fallback 모델로 재시도 |
| `ModelLoadError` (로드 실패) | ✅ | fallback 모델로 재시도 |
| `InvalidArgument` (입력 오류) | ❌ | **즉시 reject** |
| `PermissionDenied` (인증 오류) | ❌ | **즉시 reject** |
| `Unauthenticated` (API 키 오류) | ❌ | **즉시 reject** |

**fallback 미설정 시**: `fallback: null`이면 재시도 없이 즉시 실패

```python
# src/app/providers/gemini.py

FALLBACK_ERRORS = (
    NotFound,           # 모델명 오류/미지원
    ServiceUnavailable, # 5xx
    ResourceExhausted,  # 429
    ModelLoadError,     # 로드 실패
)

REJECT_IMMEDIATELY = (
    InvalidArgument,    # 입력 오류 → loud stop
    PermissionDenied,   # 인증 오류 → loud stop
    Unauthenticated,    # API 키 오류 → loud stop
)

async def extract_text(self, file_bytes: bytes, file_type: str) -> OCRResult:
    try:
        return await self._call_api(self.model, file_bytes, file_type)
    except FALLBACK_ERRORS as e:
        if self.fallback is None:
            raise OCRError("NO_FALLBACK", cause=e)
        return await self._call_api(self.fallback, file_bytes, file_type)
    except REJECT_IMMEDIATELY as e:
        raise OCRError("AUTH_OR_INPUT_ERROR", cause=e)  # 즉시 실패
```

### OCR 실패 처리

```
OCR 호출
  │
  ├─ 성공 (confidence >= 0.8) → 텍스트 반환
  │
  ├─ 부분 성공 (0.5 <= confidence < 0.8) → 텍스트 + 경고
  │
  └─ 실패 (confidence < 0.5 또는 에러)
       │
       └─ 사람 확인 UX로 되돌림
          "이미지를 인식하지 못했습니다. 직접 입력해주세요."
```

### Override 로그 스키마 (규범, v1.0)

> **스키마 버전**: `1.0`  
> 이 스키마는 규범입니다. 변경 시 버전을 올리고 마이그레이션 필요.

```json
{
  "schema_version": "1.0",
  "run_id": "uuid-v4",
  "overrides": [
    {
      "code": "OVERRIDE_APPLIED",
      "timestamp": "2024-01-15T09:30:00Z",
      "field_or_slot": "inspector",
      "type": "field",
      "reason": "현장 담당자 미지정으로 생략",
      "user": "홍길동",
      "original_value": null
    }
  ]
}
```

**필수 키 (REQUIRED)**:

| 키 | 타입 | 필수 | 설명 |
|----|------|:----:|------|
| `schema_version` | string | ✅ | "1.0" 고정 |
| `code` | string | ✅ | "OVERRIDE_APPLIED" 고정 |
| `timestamp` | ISO8601 | ✅ | 승인 시각 |
| `field_or_slot` | string | ✅ | 필드명 또는 사진 슬롯 키 |
| `type` | string | ✅ | "field" 또는 "photo" |
| `user` | string | ✅ | 승인자 (시스템이면 "system") |

**조건부 필수 (CONDITIONAL)**:

| 키 | 타입 | 조건 | 설명 |
|----|------|------|------|
| `reason` | string | `override_requires_reason=true`면 필수 | 사유 |

**옵션 (OPTIONAL)**:

| 키 | 타입 | 설명 |
|----|------|------|
| `original_value` | any | 원래 값 (있었다면) |

**실패 정책**:
- 필수 키 누락 → **로그 저장 실패 (에러)**
- 조건부 키 누락 (조건 만족 시) → **에러**
- 옵션 키 누락 → 허용

## Consequences (결과)

### 긍정적 결과

| 결과 | 설명 |
|------|------|
| **유연성** | 자연어 입력 지원 |
| **안전성** | 판정 로직이 core에 집중 |
| **추적성** | intake_session.json으로 원문 보관 |
| **교체 가능** | Provider 추상화로 모델 변경 용이 |
| **디버깅** | OCR 분리로 문제 격리 용이 |

### 부정적 결과 / 위험

| 위험 | 완화 방안 |
|------|-----------|
| **API 비용** | 간단한 패턴은 정규식 먼저 시도 |
| **환각** | LLM 제안을 core가 검증 |
| **OCR 실패** | 사람 확인 UX fallback |
| **오프라인 불가** | 에어갭 환경에서는 기존 CLI 사용 |

### 비용 관리

> ⚠️ **예상 비용은 샘플 기준 추정치**입니다.  
> 실제 비용은 입력/출력 토큰 수에 따라 크게 달라질 수 있습니다.  
> (Claude: $5/$25 per million tokens 기준)

| 모델 | 용도 | 예상 비용/건 (추정) |
|------|------|---------------------|
| Claude Opus 4.5 | 구조화 | ~$0.05 |
| Gemini 3.0 Pro | OCR (기본) | ~$0.01 |
| Gemini 2.5 Flash | OCR (fallback) | ~$0.005 |

> 💡 비용 절감: 간단한 패턴(WO-xxx, PART-xxx)은 정규식으로 먼저 시도

## References

- [spec-v2.md](../spec-v2.md) - Section 8. AI 파싱 레이어 상세
- [ADR-0001](./ADR-0001.md) - job.json SSOT
- [ADR-0002](./ADR-0002.md) - 템플릿 라이브러리
