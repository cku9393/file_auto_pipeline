# ADR-0001: job.json을 Job ID의 SSOT로 사용

| 항목 | 내용 |
|------|------|
| **상태** | Accepted |
| **작성일** | 2024-01-15 |
| **결정자** | 프로젝트 팀 |
| **관련 문서** | [spec.md](../spec.md) Section 3.4 |

## Context (배경)

제조 현장의 검사 파이프라인에서 다음 요구사항이 있습니다:

1. **추적성**: 동일한 작업(WO + Line)에 대해 여러 번 파이프라인을 실행해도 일관된 식별자로 추적 가능해야 함
2. **재현성**: "왜 같은 입력인데 결과가 달라졌나"를 즉시 확인할 수 있어야 함
3. **감사 대응**: ISO 30301 기록 관리 요구사항 충족 (진본성, 신뢰성, 무결성)
4. **동시 실행 안전**: 여러 프로세스가 동시에 같은 job 폴더에 접근할 수 있음

### 고려한 대안들

#### 대안 1: 파일명/폴더명 기반 ID

```
jobs/WO001-L1-20240115/
```

**장점**: 파일 시스템에서 직관적으로 식별 가능

**단점**:
- 폴더 이름 변경 시 ID 손실
- 동일 WO+Line의 재실행 시 ID 충돌 또는 중복 생성
- 타임스탬프 기반이면 "같은 작업"인지 판단 어려움

#### 대안 2: 데이터베이스 기반 ID

```python
job_id = db.insert(wo_no, line, ...)
```

**장점**: 중앙 집중 관리, 트랜잭션 보장

**단점**:
- 에어갭 환경(오프라인 제조 현장)에서 DB 접근 불가
- 인프라 의존성 증가
- 소규모 팀에 과도한 복잡성

#### 대안 3: job.json 파일 기반 SSOT (선택됨)

```
jobs/<folder>/job.json  ← Job ID의 유일한 진실 원천
```

**장점**:
- 오프라인 환경에서 작동
- 폴더와 함께 이동/백업 가능
- 추가 인프라 불필요
- 파일 하나로 "이 폴더가 뭔지" 즉시 파악

**단점**:
- 파일 잠금으로 동시성 제어 필요
- 파일 손상 시 복구 전략 필요

## Decision (결정)

**job.json 파일을 Job ID의 SSOT(Single Source of Truth)로 사용한다.**

### 핵심 규칙

| 규칙 | 설명 |
|------|------|
| **job_id 불변** | 최초 생성 후 절대 변경 불가 |
| **run_id 매번 발급** | 파이프라인 실행마다 새 UUID v4 |
| **디렉터리 락** | `.job_json.lock/` 으로 동시 접근 제어 |
| **원자적 쓰기** | temp 파일 → `os.rename()` |
| **mismatch 검증** | 기존 job.json의 WO/Line과 현재 packet 비교 |

### job.json 구조

```json
{
  "job_id": "WO001-L1-a3b2c1d4",
  "job_id_version": 1,
  "schema_version": "1.0",
  "created_at": "2024-01-15T09:30:00Z",
  "wo_no": "WO-001",
  "line": "L1"
}
```

### job_id 생성 규칙

```
job_id = {wo_no}-{line}-{hash8}

where:
  wo_no  = 정규화된 작업지시번호 (공백 제거, 대문자)
  line   = 정규화된 라인 ID
  hash8  = SHA256(wo_no + line + created_at)[:8]
```

### 락 정책

```
방식: 디렉터리 락 (.job_json.lock/ 생성)
기본 timeout: 2초 (40회 × 0.05초)
설정: configs/*.yaml의 pipeline.lock_timeout_seconds
실패 시: JOB_JSON_LOCK_TIMEOUT reject
```

### 동작 흐름

```
1. .job_json.lock/ 디렉터리 생성 시도
   ├─ 성공 → 락 획득
   └─ 실패 → 재시도 (최대 40회)
       └─ 초과 → JOB_JSON_LOCK_TIMEOUT reject

2. job.json 존재 확인
   ├─ 없음 → 신규 job_id 생성
   └─ 있음 → 기존 job_id 읽기
       └─ wo_no/line 불일치 → PACKET_JOB_MISMATCH reject

3. 새 run_id 생성 (UUID v4)

4. job.json 원자적 쓰기
   └─ temp 파일 작성 → os.rename()

5. .job_json.lock/ 삭제 (락 해제)
```

## Consequences (결과)

### 긍정적 결과

| 결과 | 설명 |
|------|------|
| **오프라인 작동** | DB 없이 에어갭 환경에서 사용 가능 |
| **이식성** | 폴더 복사만으로 전체 컨텍스트 이동 |
| **단순성** | 파일 하나로 "이 job이 뭔지" 파악 |
| **감사 추적** | job_id로 모든 로그/산출물 연결 |
| **재실행 안전** | 동일 폴더 재실행 시 job_id 유지 |

### 부정적 결과 / 위험

| 위험 | 완화 방안 |
|------|-----------|
| **동시 접근 충돌** | 디렉터리 락 + timeout + reject |
| **파일 손상** | 원자적 쓰기 (temp → rename) |
| **job.json 삭제** | 재실행 시 새 job_id 생성 (의도적 리셋으로 간주) |
| **락 데드락** | timeout 후 강제 reject, 수동 해제 안내 |

### 운영 가이드

#### job_id가 바뀌는 경우

| 상황 | job_id 변경 | 설명 |
|------|-------------|------|
| `--rebuild-derived` | ❌ 안 바뀜 | run_id만 새로 발급 |
| packet.xlsx 수정 | ❌ 안 바뀜 | packet_hash만 변경 |
| job.json 삭제 후 재실행 | ✅ 바뀜 | 새 job으로 간주 |
| 폴더 복사 후 실행 | ❌ 안 바뀜 | 기존 job_id 유지 |

#### 락 해제 (비상 시)

```bash
# 락 디렉터리 수동 삭제
rmdir jobs/<folder>/.job_json.lock

# 또는 강제 삭제 (파일이 있는 경우)
rm -rf jobs/<folder>/.job_json.lock
```

> ⚠️ 다른 프로세스가 실행 중이 아닌지 확인 후 수행

## References

- [spec.md](../spec.md) - Section 3.4 SSOT (job.json)
- [runbook.md](../runbook.md) - 락 해제 절차
- ISO 30301:2019 - 기록 관리 시스템
